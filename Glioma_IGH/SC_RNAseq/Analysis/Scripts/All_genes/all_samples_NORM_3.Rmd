---
title: "QC & Markers of clusters for merged samples [Normalized]"
author: "ATIA Safiya"
date: "2023-06-26"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Seurat object  
## Load required packages
```{r,  message=FALSE, warning=FALSE}
library(Seurat)
library(tidyverse)
library(ggplot2)
library(clustree)
library('enrichR')

## annotation
library(CelliD)
library(ggpubr) #for plotting

library("viridis")
```

## Load seurat object (NORM)
```{r}
seurat_obj <- readRDS(file = "merged_seurat_FindNeighbors.rds")

seurat_obj
table(seurat_obj$orig.ident)
```

## <span style="color:#296d98;"> Parameters </span>  
```{r}
res = 0.5
```

# Defining cell clusters  
## Optimize resolution  
```{r, message=FALSE}
seurat_obj <- FindClusters(seurat_obj, resolution = res)
levels(seurat_obj$seurat_clusters)
```

## Plot clusters
```{r}
DimPlot(seurat_obj, reduction = "pca", label = TRUE, group.by = "seurat_clusters") + ggtitle("PC1 vs PC2 with Clusters")
```

```{r}
DimPlot(seurat_obj, reduction = "umap", pt.size = 1, label.size = 7, label = TRUE, group.by = "seurat_clusters")
```

```{r}
DimPlot(seurat_obj, reduction = "tsne", pt.size = 1, label.size = 7, label = TRUE, group.by = "seurat_clusters")
```

## QC metrics  
Now that we have our clusters, we can look to see if they are being influenced by any of the QC metrics.  

### Nb of reads  
```{r, message=FALSE}
VlnPlot(seurat_obj, features="nCount_RNA", group.by = "seurat_clusters", pt.size = 0)
RidgePlot(seurat_obj, features = "nCount_RNA", group.by = "seurat_clusters")
```

### Nb of genes    
```{r, message=FALSE}
VlnPlot(seurat_obj, features="nFeature_RNA", group.by = "seurat_clusters", pt.size = 0)
RidgePlot(seurat_obj, features = "nFeature_RNA", group.by = "seurat_clusters")
```

### MT genes  
```{r, message=FALSE}
VlnPlot(seurat_obj, features = "percent.mt", group.by = "seurat_clusters", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.mt", group.by = "seurat_clusters")
```

### Ribosomal genes  
```{r, message=FALSE}
VlnPlot(seurat_obj, features = "percent.ribosomal", group.by = "seurat_clusters", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.ribosomal", group.by = "seurat_clusters")
```

### Largest gene  
```{r, message=FALSE}
VlnPlot(seurat_obj, features = "percent.largest_gene", group.by = "seurat_clusters", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.largest_gene", group.by = "seurat_clusters")
```

```{r}
# which largest gene
seurat_obj[[]] %>%
  group_by(seurat_clusters, largest_gene) %>%
  count() %>%
  arrange(desc(n)) %>%
  group_by(seurat_clusters) %>%
  slice(1:2) %>%
  ungroup() %>%
  arrange(seurat_clusters, desc(n))
```

### Cell cycle  
```{r}
seurat_obj@meta.data %>%
  group_by(seurat_clusters,Phase) %>%
  count() %>%
  group_by(seurat_clusters) %>%
  mutate(percent=100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=Phase)) +
  geom_col() +
  ggtitle("Percentage of cell cycle phases per cluster")
```

# Finding markers for each cluster  
Identify genes whose expression defines each cluster which has been identified.

* **The Wilcox rank sum test**: This identifies genes which are differentially regulated between two groups of cells. It is a non-parametric test which makes very few assumptions about the behaviour of the data and just looks for genes which have expression which is consistently ranked more highly in one group of cells compared to another.  

* **The ROC test**: This is a measure of how specifically a gene can predict membership of two groups. It gives a value between 0.5 (no predictive value) and 1 (perfectly predictive on its own) to say how useful each gene is at predicting. Again this is a non-parametric test which just cares about the ranked expression measures for each gene.

## Predictions  
```{r}
# This loop just runs the FindMarkers function on all of the clusters
lapply(
  levels(seurat_obj[["seurat_clusters"]][[1]]),
  function(x)FindMarkers(seurat_obj,ident.1 = x, min.pct = 0.25)
) -> cluster.markers


# This simply adds the cluster number to the results of FindMarkers
sapply(0:(length(cluster.markers)-1),function(x) {
  cluster.markers[[x+1]]$gene <<- rownames(cluster.markers[[x+1]])
  cluster.markers[[x+1]]$cluster <<- x
})

# Finally we collapse the list of hits down to a single table and sort it by FDR to put the most significant ones first
as_tibble(do.call(rbind,cluster.markers)) %>% arrange(p_val_adj) -> cluster.markers

# Extract the most upregulated gene from each cluster
cluster.markers %>%
  group_by(cluster) %>%
    slice(1) %>%
      pull(gene) -> best.wilcox.gene.per.cluster

best.wilcox.gene.per.cluster
```

For some clusters, we might have a gene which can uniquely predict them but for many others we have a hit which also picks up other clusters. 

We can try to clean this up for any individual cluster by using the **roc analysis**.

* **Power value** : A value of 1 is perfectly separating, and a value of 0 is random.

```{r, eval=FALSE}
# here it's a comparison between cluster 0 and 2.
# best positive hit = more expressed in cluster 0.
FindMarkers(seurat_obj, ident.1 = 0, ident.2 = 2, test.use = "roc", only.pos = TRUE)
```

## Cluster biomarkers  
* `DoHeatmap` generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster.

```{r, warning=FALSE, message=FALSE}
# find markers for every cluster compared to all remaining cells, report only the positive ones
markers <- FindAllMarkers(seurat_obj, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
```

```{r}
top <- markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
DoHeatmap(seurat_obj, features = top$gene) + NoLegend()
```

# Save seurat object  
```{r}
saveRDS(seurat_obj, file ="merged_seurat_Markers.rds")
```
