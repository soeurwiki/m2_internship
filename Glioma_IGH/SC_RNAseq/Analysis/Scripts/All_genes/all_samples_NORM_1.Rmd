---
title: "QC & PCA for merged samples [Normalized]"
author: "ATIA Safiya"
date: "2023-06-26"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Seurat object  
## Load required packages  
```{r,  message=FALSE, warning=FALSE}
library(Seurat)
library(tidyverse)
library(ggplot2)
library(sctransform)
```

## Load seurat object (RAW)  
```{r}
seurat_obj <- readRDS(file = "Raw_merged_seurat.rds")

seurat_obj
table(seurat_obj$orig.ident)
```

# Normalization    
*run on the cluster*

**SCTransform** : replace  `NormalizeData()`, `ScaleData()`, and `FindVariableFeatures()`.This procedure omits the need for heuristic steps including *pseudocount addition* or *log-transformation* and improves common downstream analytical tasks such as variable gene selection, dimensional reduction, and differential expression.  
During normalization, we can also remove confounding sources of variation, for example, mitochondrial mapping percentage.

```{r, eval=FALSE}
seurat_obj <- SCTransform(seurat_obj, method = "glmGamPoi", vst.flavor = "v2", verbose = FALSE)
```
*method = "glmGamPoi"  improves the speed of the learning procedure*

```{r, echo=FALSE}
seurat_obj <- readRDS("sctransform.rds")
seurat_obj
```

```{r, warning=FALSE}
tibble(
  pc95 = apply(seurat_obj[["RNA"]]@data,2,quantile,0.95),
  measured = apply(seurat_obj[["RNA"]]@data,2,function(x)(100*sum(x!=0))/length(x))
) -> normalisation.qc

normalisation.qc %>% 
  ggplot(aes(x=measured,y=pc95))+
  geom_point()+
  ggtitle("Normalisation of data")
```

# QC metrics  
```{r}
FeatureScatter(seurat_obj, feature1 = "nCount_RNA", feature2 = "percent.mt", group.by ="orig.ident")
FeatureScatter(seurat_obj,feature1 = "nCount_RNA", feature2 = "percent.largest_gene",group.by ="orig.ident")

FeatureScatter(seurat_obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA",group.by ="orig.ident") + geom_smooth(method = 'lm')
```
```{r, message=FALSE, warning=FALSE}
library(viridis)
metadata <- seurat_obj@meta.data
```

## Nb of reads  
```{r, message=FALSE}
VlnPlot(seurat_obj,features="nCount_RNA", group.by = "orig.ident", pt.size = 0)
RidgePlot(seurat_obj, features = "nCount_RNA", group.by = "orig.ident")

metadata %>% 
  ggplot(aes( x=nCount_RNA,y=orig.ident, fill= orig.ident)) + 
	geom_boxplot() + 
	theme_classic()+
	scale_fill_viridis(	option="magma",discrete = TRUE, alpha=0.6) +
  scale_x_log10()
```

## Nb of genes  
```{r, message=FALSE}
VlnPlot(seurat_obj,features="nFeature_RNA", group.by = "orig.ident", pt.size = 0)
RidgePlot(seurat_obj, features = "nFeature_RNA", group.by = "orig.ident")

metadata %>% 
  ggplot(aes( x=nFeature_RNA,y=orig.ident, fill= orig.ident)) + 
	geom_boxplot() + 
	theme_classic()+
	scale_fill_viridis(	option="magma",discrete = TRUE, alpha=0.6) +
  scale_x_log10()
    
```

```{r}
ggplot(qc.metrics) + 
   geom_histogram(aes(nFeature_RNA, 
                  color = "#173664"),
                  binwidth = 50) + 
  ggtitle("Distribution of nFeature_RNA ") + NoLegend()
```

## Gene expression  
We can pick the first 100 cells and look at the distributions of their expression values.

```{r, warning=FALSE}
apply(seurat_obj@assays$RNA@data,1,mean) -> gene.expression
sort(gene.expression, decreasing = TRUE) -> gene.expression

as.tibble(
  seurat_obj@assays$RNA@data[,1:100]
) %>%
  pivot_longer(
    cols=everything(),
    names_to="cell",
    values_to="expression"
  ) %>%
  ggplot(aes(x=expression, group=cell)) +
  geom_density() +
  coord_cartesian(ylim=c(0,0.6), xlim=c(0,3))
```

## MT genes  
```{r, message=FALSE}
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^MT-")
VlnPlot(seurat_obj, features = "percent.mt", group.by = "orig.ident", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.mt", group.by = "orig.ident")
```

```{r}
ggplot(qc.metrics) + 
   geom_histogram(aes(percent.mt, 
                  color = "#173664"),
                  binwidth = 0.5) + 
  ggtitle("Distribution of Percentage Mitochondrion") + NoLegend()
```

## Ribosomal genes  
```{r, message=FALSE}
PercentageFeatureSet(seurat_obj,pattern="^RP[LS]") -> seurat_obj[["percent.ribosomal"]] 
VlnPlot(seurat_obj, features = "percent.ribosomal", group.by = "orig.ident", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.ribosomal", group.by = "orig.ident")
```

```{r}
ggplot(qc.metrics) + 
   geom_histogram(aes(percent.largest_gene, 
                  color = "#173664"),
                  binwidth = 0.7) + 
  ggtitle("Distribution of Percentage Largest Gene") + NoLegend()
```

## Largest gene  
```{r, message=FALSE}
apply(
  seurat_obj@assays$RNA@counts,
  2,
  max
) -> largest_count

apply(
  seurat_obj@assays$RNA@counts,
  2,
  which.max
) -> largest_index

rownames(seurat_obj)[largest_index] -> seurat_obj$largest_gene

100 * largest_count / seurat_obj$nCount_RNA -> seurat_obj$percent.largest_gene

VlnPlot(seurat_obj,features="percent.largest_gene", group.by = "orig.ident", pt.size = 0)
RidgePlot(seurat_obj, features = "percent.largest_gene", group.by = "orig.ident")
```

```{r}
ggplot(qc.metrics) + 
   geom_histogram(aes(percent.largest_gene, 
                  color = "#173664"),
                  binwidth = 0.7) + 
  ggtitle("Distribution of Percentage Largest Gene") + NoLegend()
```

## Cell cycle scoring  
```{r, warning=FALSE}
seurat_obj <- CellCycleScoring(seurat_obj, s.features = cc.genes.updated.2019$s.genes, g2m.features = cc.genes.updated.2019$g2m.genes, set.ident = TRUE)

seurat_obj@meta.data %>%
  group_by(orig.ident,Phase) %>%
  count() %>%
  group_by(orig.ident) %>%
  mutate(percent=100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=orig.ident,y=percent, fill=Phase)) +
  scale_fill_manual( values=c(G1='azure4',G2M='dodgerblue',S='tomato3' )) +
  geom_col() +
  ggtitle("Percentage of cell cycle phases per sample")

as_tibble(seurat_obj[[]]) %>%
  ggplot(aes(Phase, fill=Phase)) +
  scale_fill_manual( values=c(G1='azure4',G2M='dodgerblue',S='tomato3' ))+ geom_bar()


as_tibble(seurat_obj[[]]) %>%
  ggplot(aes(x=S.Score, y=G2M.Score, color=Phase)) + 
  scale_color_manual( values=c(G1='azure4',G2M='dodgerblue',S='tomato3' )) +
  geom_point() +
  coord_cartesian(xlim=c(-0.15,0.15), ylim=c(-0.15,0.15))
```

# Identify high variable features  
*Included in the `SCTransform` function.*

```{r}
# identify the 10 most highly variable genes
top10 <- head(VariableFeatures(metabo_obj), 10)

# plot the variable features 
plot <- VariableFeaturePlot(metabo_obj)
LabelPoints(plot = plot, points = head(top10,10), repel = TRUE)
```

We can plot out a graph of the variance vs mean and highlight the selected genes so we can see whether we think weâ€™re likely to capture what we need.    

```{r}
as_tibble(HVFInfo(metabo_obj),rownames = "Gene") -> variance.data

variance.data %>% 
  mutate(hypervariable=Gene %in% VariableFeatures(metabo_obj)
) -> variance.data

variance.data %>% 
  ggplot(aes(log(mean),log(variance),color=hypervariable)) + 
  geom_point() + 
  scale_color_manual(values=c("black","red"))
```
  

# Scaling the data  
*Included in the `SCTransform` function.*

**ScaleData** :

* Shifts the expression of each gene, so that the mean expression across cells is 0
* Scales the expression of each gene, so that the variance across cells is 1 
    + This step gives equal weight in downstream analyses, so that highly-expressed genes do not 

# Linear dimensional reduction  
## PCA  
```{r}
metabo_obj <- RunPCA(metabo_obj, features = VariableFeatures(object = metabo_obj))
VizDimLoadings(metabo_obj, dims = 1:2, reduction = "pca")
```

```{r}
DimPlot(metabo_obj, reduction = "pca", group.by = "orig.ident")
DimPlot(metabo_obj, reduction = "pca", group.by = "Phase", cols = c(G1='azure4',G2M='dodgerblue',S='tomato3'))
DimPlot(metabo_obj, reduction = "pca", group.by = "largest_gene", label = TRUE, label.size = 3) + NoLegend()
```

### Save seurat object  
```{r}
saveRDS(seurat_obj, file ="Norm_merged_seurat.rds")
```

## Determine the dimensionality of the dataset  
*run on the cluster*

how many components should we choose to include?  

**JackStrawPlot**  
*significant* PCs as those who have a strong enrichment of **low p-value**

* dashed line : uniform distribution
* solid curve above dash line : strong enrichments of features with low p-values

**ElbowPlot**  
ranking of principle components based on the percentage of variance explained by each one 

```{r, eval=FALSE}
metabo_obj <- JackStraw(metabo_obj, num.replicate = 100, dims = 40)
jack.data <- metabo_obj 

metabo_obj <- ScoreJackStraw(metabo_obj, dims = 1:40)

JackStrawPlot(metabo_obj, dims = 1:40)
ElbowPlot(metabo_obj, ndims = 40)
```